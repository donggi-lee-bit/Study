[# 객체지향개념

### 클래스의 정의
클래스란 객체를 정의해 놓은 것

###클래스의 용도
클래스는 객체를 생성하는데 사용

### 객체와 인스턴스
- 객체
  - 모든 인스턴스를 대표하는 일반적 용어
- 인스턴스
  - 특정 클래스로부터 생성된 객체

클래스 (설계도) ----------> 인스턴스 (객체)
### 객체의 생성과 사용
```
Tv t = new Tv();
```
t = 리모컨 역할을 한다

### 순서
1. 클래스 작성
2. 객체 생성
3. 객체 사용


## 객체 배열
참조변수 배열이라고도 한다
```java
Tv tv1, tv2, tv3;
==> Tv[] tvArr = new Tv[3];

Tv[] tvArr = new Tv[3]; // 길이가 3인 Tv타입의 참조변수 배열
        
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();

// 요걸 배열로 나타낸 게 위 코드
Tv t1 = new Tv();
Tv t2 = new Tv();
Tv t3 = new Tv();
```

## 클래스의 정의

클래스 == 데이터 + 함수

1. 변수 : 하나의 데이터를 저장할 수 있는 공간
2. 배열 : 같은 종류의 여러 데이터를 하나로 저장할 수 있는 공간
3. 구조체 : 서로 관련된 여러 데이터를 하나로 저장할 수 있는 공간
4. 클래스 : 데이터와 함수의 결합 (구조체 + 함수)

```java
int hour;
int minute;
int second;

int hour1, hour2, hour3;
int minute1, minute2, minute3;
int second1, second2, second3;

int[] hour = new int[3];
int[] minute = new int[3];
int[] second = new int[3];

=======>

Class Time {
    int hour;
    int minute;
    int second;
}
        
Time t = new Time();

Time t1 = new Time();
Time t2 = new Time();
Time t3 = new Time();

Time[] t = new Time[3];
t[0] = new Time();
t[1] = new Time();
t[2] = new Time();

```
### 선언 위치에 따른 변수의 종류

```java
class Variables {
    int iv; // 인스턴스 변수
    static int cv; // 클래스 변수 (static변수, 공유변수)
  void method() {
      int lv = 0; // 지역변수
  } 
}
```
|변수의 종류|선언위치|생성시기|
|------|---|---|
|클래스 변수|클래스 영역|클래스가 메모리에 올라갈 때|
|인스턴스 변수|클래스 영역|**인스턴스가 생성되었을 때**|
|지역변수|클래스 영역 이외의 영역|변수 선언문이 수행되었을 때|


## 메서드

1. 문장을 묶은 것
2. 값을 받아 처리하고, 결과를 반환

### 메서드의 장점
- 코드의 중복을 줄일 수 있다
- 코드의 관리가 쉽다
- 코드를 재사용할 수 있다
- 코드가 간결해서 이해하기 쉬워진다

### 메서드의 작성

- 반복적으로 수행되는 여러 문장을 메서드로 작성한다
- 하나의 메서드는 한 가지 기능만 수행하도록 작성한다 (배열 초기화, 배열 출력 각각의 메서드로 나누어서 만든다)

## 호출 스택
메서드 수행에 필요한 메모리가 제공되는 공간
<br>
메서드가 호출되면 호출스택에 메모리 할당, 종료되면 해제
<br>
아래 있는 메서드가 위의 메서드를 호출한 것
<br>
맨 위의 메서드 하나만 실행 중이고 나머지는 대기중이다

### 스택
밑이 막힌 상자. 위에 차곡차곡 쌓인다 <br>
꺼낼 땐 제일 위에 있는 것부터 나간다

## 매개변수

### 기본형 매개변수
변수의 값을 읽기만 할 수 있다. 변경이 불가하다
### 참조형 매개변수
변수의 값을 읽고 변경할 수 있다

## static 메서드와 인스턴스 메서드

- 인스턴스 메서드
  - 인스턴스 생성 후, '참조변수.메서드이름()'으로 호출
  - 인스턴스 멤버(iv, im)와 관련된 작업을 하는 메서드
  - 메서드 내에서 인스턴스 변수 사용가능

- static 메서드(클래스 메서드)
  - 객체 생성없이 '클래스이름.메서드이름()'으로 호출 가능
  - 인스턴스 멤버와 관련없는 작업을 하는 메서드
  - 메서드 내에서 인스턴스 변수 사용불가

### static 메서드와 인스턴스 메서드의 차이
인스턴스 변수의 사용 가능여부 (인스턴스 메서드는 사용 가능, static 메서드는 불가능)

### static 메서드에 static을 붙이는 이유
인스턴스 변수를 사용하지 않을 때 붙인다

### static을 붙이는 때
- static 변수는 공통속성
- 인스턴스 변수는 개별속성
- 인스턴스 멤버를 사용하지 않는 메서드에 static을 붙인다

## 오버로딩
한 클래스 안에 같은 이름의 메서드 여러 개를 정의하는 것

### 오버로딩 성립하는 조건
1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.
3. 반환 타입은 영향을 주지 않는다.

```
int add(int a, int b) { return a + b; }
int add(int x, int y) { return x + y; }
```
- 위의 예제는 오버로딩이 아니다
  - 매개변수의 개수 또는 타입이 달라야하는데 같기 때문

```
int add(int a, int b) { return a + b; }
long add(int a, int b) { return (long)(a + b); }
```
- 위 예제 또한 오버로딩이 성립하지 않는다
  - 반환 타입이 다르긴 하지만 반환 타입은 영향을 주지 않습니다
  - 매개 변수의 타입과 개수가 같기 때문입니다

```
long add(int a, long b) { return a + b; }
long add(long a, int b) { return a + b; }
```
- 위 예제가 이제 오버로딩을 성립한다.
  - 메서드 이름이 같고,
  - 매개변수의 개수는 같지만 타입이 다르기 때문이다

- 위 예제는 호출할 때 유의할 점이 있다.
  - add(3, 3); 이렇게 호출하게 되면 컴파일러가 둘 중에 어느것을 호출해야 할 지 모른다 (ambiguous, 모호하다)
  - add(3, 3L); 하게 되면 첫번째 add 메서드를 호출할 수 있다
